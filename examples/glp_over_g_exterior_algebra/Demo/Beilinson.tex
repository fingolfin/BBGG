\documentclass[16pt,a4paper]{extarticle}
    \usepackage[a4paper,margin=12mm]{geometry}
    \usepackage{amsmath}
    \usepackage{amsthm}
    \usepackage{amssymb}
    \usepackage{hyperref}
    \usepackage{fancyvrb}
    \usepackage{xcolor}
    \usepackage{tikz}
    \usetikzlibrary{matrix}
    
    \theoremstyle{definition}
    \newtheorem{definition}{Definition}
    \newtheorem{idea}{Idea}
    
    \theoremstyle{theorem}
    \newtheorem{theorem}{Theorem}
    
\newcommand{\LL}{\mathbf{L}}
\newcommand{\HH}{\mathbf{H}}
\newcommand{\RR}{\mathbf{R}}
\newcommand{\TT}{\mathbf{T}}
\newcommand{\trunc}{\mathbf{trunc}}

\definecolor{my_color}{rgb}{0.0, 0.48, 0.65}
\definecolor{rule_color}{rgb}{1.0, 0.65, 0.0}

    \title{Example about BGG correspondence}
    \author{Kamal Saleh}
    \begin{document}
    \maketitle
    \tableofcontents
    \section{The functors $\RR$ and $\LL$}
    In the following $S$ is the graded polynomial ring $\mathbb{Q}[x_0,\dots,x_n]$ with 
    $\mathrm{deg}(x_i)=1,i=0,\dots,n$ and $A$ is its dual graded ring, i.e., the exterior algebra
    generated by $e_i,i=0,\dots,n$ with $\mathrm{deg}(e_i)=-1$ and $\omega_A := \mathrm{Hom}_k(E,k)\cong A(n+1)$.
    \begin{definition}
        Given a graded $S$-module $M=\bigoplus_{d\in\mathbb{Z}} M_d$, we construct the following cochain complex of graded $A$-modules:
        $$\RR(M):\dots \rightarrow M_{i-1}\otimes_k \omega_A\rightarrow M_{i}\otimes_k \omega_A \rightarrow \dots$$
        where the term $M_{i}\otimes_k \omega_A$ has cohomological degree $i$.
    \end{definition}
    \begin{definition}
        Given a graded $A$-module $P=\bigoplus_{d\in\mathbb{Z}} P_d$, we construct the following cochain complex of graded $S$-modules:
        $$\LL(P):\dots \rightarrow S \otimes_k P_{j}\rightarrow S \otimes_k P_{j-1} \rightarrow \dots$$
        where the term  $S \otimes_k P_{j}$ has cohomological degree $-j$.
    \end{definition}
    \begin{theorem}
        If $M$ is finitely generated graded $S$-module and $P$ is a finitely generated graded $A$-module, then $\LL(P)$ is free resolution of $M$ if and 
        only if $\RR(M)$ is an injective resolution of $P$.
    \end{theorem}
    \begin{idea}
        If $M$ is finitely generated graded $S$-module and $r\geq\mathrm{reg}(M)$, then $\LL(\HH^r( \RR^{> r-1}(M)) )$ is free resolution of $M_{\geq r}$.\\
        Here $\RR^{> r-1}(M) = \trunc^{> r-1}_{below}(\RR(M))$.
        Of course, we can replace $\RR$ by $\TT$ (the Tate functor).
    \end{idea}

\begin{Verbatim}[commandchars=\\\{\}, fontseries=b, frame=single, label=Gap Code, framerule=0.5mm, rulecolor=\color{rule_color}]
    \textcolor{my_color}{S;}
    \textcolor{my_color}{A;}
    \textcolor{my_color}{m := RandomMatrixBetweenGradedFreeLeftModules( [ 5, 4 ],[ 4, 2, 3, 1 ], S );}
    \textcolor{my_color}{M := AsGradedLeftPresentation( m, [ 4, 2, 3, 1 ] );}
    \textcolor{my_color}{Display( M );}
    \textcolor{my_color}{r := Maximum( 1, CastelnuovoMumfordRegularity( M ) );}
    \textcolor{my_color}{M_geq_r := GradedLeftPresentationGeneratedByHomogeneousPart( M, r );}
    \textcolor{my_color}{R := RFunctor( S );}
    \textcolor{my_color}{trunc_g_rm1_below := BrutalTruncationBelowFunctor( cochains_graded_lp_cat_ext, r - 1 );}
    \textcolor{my_color}{H_r := CohomologyFunctorAt( cochains_graded_lp_cat_ext, graded_lp_cat_ext, r );}
    \textcolor{my_color}{L := LFunctor( S );}
    \textcolor{my_color}{Free_res := PreCompose( [ R, trunc_g_rm1_below, H_r, L ] );}
    \textcolor{my_color}{F := ApplyFunctor( Free_res, M_geq_r );}
    \textcolor{my_color}{RM_geq_r := ApplyFunctor(R,M_geq_r);;}
    \textcolor{my_color}{P := Source( CyclesAt( RM_geq_r, r ) );;}
    \textcolor{my_color}{P_leq_r := GradedLeftPresentationGeneratedByHomogeneousPart(P,r);;}
    \textcolor{my_color}{emb_P_leq_r_in_P := EmbeddingInSuperObject( P_leq_r );}
    \textcolor{my_color}{h := PreCompose( emb_P_leq_r_in_P, CyclesAt( RM_geq_r, r ) );}
    \textcolor{my_color}{mat := UnderlyingMatrix(h);}
    \textcolor{my_color}{mat := DecompositionOfHomalgMat(mat)[2^(l+1)][2]*S;}
    \textcolor{my_color}{t := GradedPresentationMorphism( F[ -r ], mat, M_geq_r );}
    \textcolor{my_color}{IsZero( PreCompose( F^(-r-1), t ) );}
    \textcolor{my_color}{iso := CokernelColift( F^(-r-1), t );}
    \textcolor{my_color}{IsIsomorphism( iso );}
\end{Verbatim}
    
\begin{idea}
    If $M$ is finitely generated graded $S$-module and $r\geq\mathrm{reg}(M)$, Then the exactness of $\TT(M)$ implies
    $$\HH^r( \TT^{> r-1}(M))\cong \HH^{r-1}( \TT^{\leq r-1}(M)),$$ hence, 
    $\LL(\HH^r( \TT^{> r-1}(M)) )$ and $\LL(\HH^{r-1}( \TT^{\leq r-1}(M)) )$ are isomorphic. In particular 
    $\LL(\HH^{r-1}( \TT^{\leq r-1}(M)) )$ is free resolution of $M_{\geq r}$.
        Here $\TT^{\leq r-1}(M) = \trunc^{\leq r-1}_{above}(\TT(M))$.
\end{idea}

\begin{Verbatim}[commandchars=\\\{\}, fontseries=b, frame=single, label=Gap Code, framerule=0.5mm, rulecolor=\color{rule_color} ]
\textcolor{my_color}{TM := ApplyFunctor( T, M );}
\textcolor{my_color}{u_shift_m1 := UnsignedShiftFunctor( cochains_graded_lp_cat_ext, -1 );}
\textcolor{my_color}{TM_g_rm1 := ApplyFunctor( trunc_g_rm1_below, TM );}
\textcolor{my_color}{TM_leq_rm1 := ApplyFunctor( trunc_leq_rm1_above, TM );}
\textcolor{my_color}{TM_leq_rm1_shifted := ApplyFunctor( u_shift_m1, TM_leq_rm1 );}
\textcolor{my_color}{phi := CochainMorphism( TM_leq_rm1_shifted, TM_g_rm1, [ TM^(r-1) ], r  );}
\textcolor{my_color}{IsWellDefined( phi, ActiveLowerBound( phi ), ActiveUpperBound( phi ) );}
\textcolor{my_color}{i := ApplyFunctor( H_r, phi );}
\textcolor{my_color}{IsIsomorphism( i );}
\textcolor{my_color}{Display( i );}
\textcolor{my_color}{Li := ApplyFunctor( L, i );}
\textcolor{my_color}{IsWellDefined(Li);}
\textcolor{my_color}{IsIsomorphism(Li);}
\textcolor{my_color}{H_mr := CohomologyFunctorAt( cochains_graded_lp_cat_sym, graded_lp_cat_sym, -r );}
\textcolor{my_color}{H_mr_Li := ApplyFunctor( H_mr, Li );}
\textcolor{my_color}{Display( H_mr_Li );}
\textcolor{my_color}{IsIsomorphism( H_mr_Li );}
\end{Verbatim}

    
    \begin{idea}
        If $M$ is finitely generated graded $S$-module and $r\geq\mathrm{reg}(M)$.
    \end{idea}
    \begin{Verbatim}[commandchars=\\\{\}, fontseries=b, frame=single, label=Gap Code, framerule=0.5mm, rulecolor=\color{rule_color} ]
    \textcolor{my_color}{r := Maximum( CastelnuovoMumfordRegularity(M), 1 );}
    \textcolor{my_color}{trunc_leq_r := BrutalTruncationAboveFunctor(cochains_graded_lp_cat_ext, r );;}
    \textcolor{my_color}{trunc_g_r := BrutalTruncationBelowFunctor(cochains_graded_lp_cat_ext,r);;}
    \textcolor{my_color}{T := TateFunctor(S);}
    \textcolor{my_color}{trunc_leq_m1 := BrutalTruncationAboveFunctor( cochains_graded_lp_cat_sym, -1 );;}
    \textcolor{my_color}{Ch_trunc_leq_m1 := ExtendFunctorToCochainComplexCategoryFunctor(trunc_leq_m1 );;}
    \textcolor{my_color}{complexes_sym := CochainComplexCategory( cochains_graded_lp_cat_sym );;}
    \textcolor{my_color}{bicomplxes_sym := AsCategoryOfBicomplexes(complexes_sym);;}
    \textcolor{my_color}{complexes_to_bicomplex := ComplexOfComplexesToBicomplexFunctor(complexes_sym, bicomplxes_sym );;}
    \textcolor{my_color}{L := LFunctor(S);}
    \textcolor{my_color}{ChL := ExtendFunctorToCochainComplexCategoryFunctor(L);;}
    \textcolor{my_color}{shift_step_to_left := UnsignedShiftFunctor(cochains_graded_lp_cat_ext, 1);;}
    \textcolor{my_color}{T1 := PreCompose( [ T, trunc_leq_r ] );;}
    \textcolor{my_color}{T2 := PreCompose( [ T, trunc_g_r ] );;}    
    \textcolor{my_color}{T2_shifted := PreCompose( [ T, trunc_g_r, shift_step_to_left ] );;}
    \textcolor{my_color}{tM := ApplyFunctor( T, M );;}
    \textcolor{my_color}{tM1 := ApplyFunctor( T1, M );;}
    \textcolor{my_color}{tM2 := ApplyFunctor( T2, M );;}
    \textcolor{my_color}{tM2_shifted := ApplyFunctor( T2_shifted, M );;}
    \textcolor{my_color}{phi := CochainMorphism( tM1, tM2_shifted, [ tM^r ], r );;}
    \textcolor{my_color}{F := PreCompose( [ ChL, Ch_trunc_leq_m1, complexes_to_bicomplex ] );;}
    \textcolor{my_color}{FtM1 := ApplyFunctor(F,tM1);;}
    \textcolor{my_color}{FtM2 := ApplyFunctor(F,tM2);;}
    \textcolor{my_color}{Fphi := ApplyFunctor(F,phi);;}
    \textcolor{my_color}{f := ComplexMorphismOfHorizontalCohomologiesAt( Fphi, r );;}
    \textcolor{my_color}{H_mrm1 := CohomologyFunctorAt( cochains_graded_lp_cat_sym, graded_lp_cat_sym, -r-1 );;}
    \textcolor{my_color}{iso := ApplyFunctor( H_mrm1, f );;}
    \textcolor{my_color}{IsIsomorphism( iso );}
    
\end{Verbatim}
\end{document}